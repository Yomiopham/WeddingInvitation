"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValueApi = exports.StringApi = exports.ObjectApi = exports.ConstApi = exports.BinaryApi = exports.TupleApi = exports.ArrayApi = exports.NodeApi = void 0;
const ArrayRga_1 = require("../../types/rga-array/ArrayRga");
const BinaryRga_1 = require("../../types/rga-binary/BinaryRga");
const Const_1 = require("../../types/const/Const");
const find_1 = require("./find");
const clock_1 = require("../../../json-crdt-patch/clock");
const ObjectLww_1 = require("../../types/lww-object/ObjectLww");
const StringRga_1 = require("../../types/rga-string/StringRga");
const ValueLww_1 = require("../../types/lww-value/ValueLww");
const ArrayLww_1 = require("../../types/lww-array/ArrayLww");
const NodeEvents_1 = require("./events/NodeEvents");
class NodeApi {
    constructor(node, api) {
        this.node = node;
        this.api = api;
        this.ev = undefined;
    }
    get events() {
        const et = this.ev;
        return et || (this.ev = new NodeEvents_1.NodeEvents(this));
    }
    find(path) {
        const node = this.node;
        if (path === undefined) {
            if (typeof node.child === 'function') {
                const child = node.child();
                if (!child)
                    throw new Error('NO_CHILD');
                return child;
            }
            throw new Error('CANNOT_IN');
        }
        if (typeof path === 'string' && !!path && path[0] !== '/')
            path = '/' + path;
        if (typeof path === 'number')
            path = [path];
        return (0, find_1.find)(this.node, path);
    }
    in(path) {
        const node = this.find(path);
        return this.api.wrap(node);
    }
    asVal() {
        if (this.node instanceof ValueLww_1.ValueLww)
            return this.api.wrap(this.node);
        throw new Error('NOT_VAL');
    }
    asStr() {
        if (this.node instanceof StringRga_1.StringRga)
            return this.api.wrap(this.node);
        throw new Error('NOT_STR');
    }
    asBin() {
        if (this.node instanceof BinaryRga_1.BinaryRga)
            return this.api.wrap(this.node);
        throw new Error('NOT_BIN');
    }
    asArr() {
        if (this.node instanceof ArrayRga_1.ArrayRga)
            return this.api.wrap(this.node);
        throw new Error('NOT_ARR');
    }
    asTup() {
        if (this.node instanceof ArrayLww_1.ArrayLww)
            return this.api.wrap(this.node);
        throw new Error('NOT_ARR');
    }
    asObj() {
        if (this.node instanceof ObjectLww_1.ObjectLww)
            return this.api.wrap(this.node);
        throw new Error('NOT_OBJ');
    }
    asConst() {
        if (this.node instanceof Const_1.Const)
            return this.api.wrap(this.node);
        throw new Error('NOT_CONST');
    }
    asExt(ext) {
        let node = this.node;
        while (node) {
            if (node instanceof ext.Node)
                return new ext.Api(node, this.api);
            node = node.child ? node.child() : undefined;
        }
        throw new Error('NOT_EXT');
    }
    val(path) {
        return this.in(path).asVal();
    }
    str(path) {
        return this.in(path).asStr();
    }
    bin(path) {
        return this.in(path).asBin();
    }
    arr(path) {
        return this.in(path).asArr();
    }
    tup(path) {
        return this.in(path).asTup();
    }
    obj(path) {
        return this.in(path).asObj();
    }
    const(path) {
        return this.in(path).asConst();
    }
    view() {
        return this.node.view();
    }
}
exports.NodeApi = NodeApi;
class ArrayApi extends NodeApi {
    ins(index, values) {
        const { api, node } = this;
        const { builder } = api;
        const after = !index ? node.id : node.find(index - 1);
        if (!after)
            throw new Error('OUT_OF_BOUNDS');
        const valueIds = [];
        for (let i = 0; i < values.length; i++)
            valueIds.push(builder.json(values[i]));
        builder.insArr(node.id, after, valueIds);
        api.apply();
        return this;
    }
    del(index, length) {
        const { api, node } = this;
        const spans = node.findInterval(index, length);
        if (!spans)
            throw new Error('OUT_OF_BOUNDS');
        api.builder.del(node.id, spans);
        api.apply();
        return this;
    }
    length() {
        return this.node.length();
    }
}
exports.ArrayApi = ArrayApi;
class TupleApi extends NodeApi {
    set(entries) {
        const { api, node } = this;
        const { builder } = api;
        builder.insVec(node.id, entries.map(([index, json]) => [index, builder.constOrJson(json)]));
        api.apply();
        return this;
    }
}
exports.TupleApi = TupleApi;
class BinaryApi extends NodeApi {
    ins(index, data) {
        const { api, node } = this;
        const after = !index ? node.id : node.find(index - 1);
        if (!after)
            throw new Error('OUT_OF_BOUNDS');
        api.builder.insBin(node.id, after, data);
        api.apply();
        return this;
    }
    del(index, length) {
        const { api, node } = this;
        const spans = node.findInterval(index, length);
        if (!spans)
            throw new Error('OUT_OF_BOUNDS');
        api.builder.del(node.id, spans);
        api.apply();
        return this;
    }
}
exports.BinaryApi = BinaryApi;
class ConstApi extends NodeApi {
    view() {
        return this.node.view();
    }
}
exports.ConstApi = ConstApi;
class ObjectApi extends NodeApi {
    set(entries) {
        const { api, node } = this;
        const { builder } = api;
        builder.setKeys(node.id, Object.entries(entries).map(([key, json]) => [key, builder.constOrJson(json)]));
        api.apply();
        return this;
    }
    del(keys) {
        const { api, node } = this;
        const { builder } = api;
        api.builder.setKeys(node.id, keys.map((key) => [key, builder.const(undefined)]));
        api.apply();
        return this;
    }
}
exports.ObjectApi = ObjectApi;
class StringApi extends NodeApi {
    ins(index, text) {
        const { api, node } = this;
        const builder = api.builder;
        builder.pad();
        const nextTime = api.builder.nextTime();
        const id = new clock_1.Timestamp(builder.clock.sid, nextTime);
        const after = node.insAt(index, id, text);
        if (!after)
            throw new Error('OUT_OF_BOUNDS');
        builder.insStr(node.id, after, text);
        api.advance();
        return this;
    }
    del(index, length) {
        const { api, node } = this;
        const builder = api.builder;
        builder.pad();
        const spans = node.findInterval(index, length);
        if (!spans)
            throw new Error('OUT_OF_BOUNDS');
        node.delete(spans);
        builder.del(node.id, spans);
        api.advance();
        return this;
    }
}
exports.StringApi = StringApi;
class ValueApi extends NodeApi {
    set(json) {
        const { api, node } = this;
        const builder = api.builder;
        const val = builder.constOrJson(json);
        api.builder.setVal(node.id, val);
        api.apply();
        return this;
    }
}
exports.ValueApi = ValueApi;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Encoder = void 0;
const ArrayRga_1 = require("../../../types/rga-array/ArrayRga");
const BinaryRga_1 = require("../../../types/rga-binary/BinaryRga");
const ClockEncoder_1 = require("../../../../json-crdt-patch/codec/clock/ClockEncoder");
const Const_1 = require("../../../types/const/Const");
const CrdtEncoder_1 = require("../../../../json-crdt-patch/util/binary/CrdtEncoder");
const clock_1 = require("../../../../json-crdt-patch/clock");
const msgpack_1 = require("../../../../json-pack/msgpack");
const ObjectLww_1 = require("../../../types/lww-object/ObjectLww");
const StringRga_1 = require("../../../types/rga-string/StringRga");
const ValueLww_1 = require("../../../types/lww-value/ValueLww");
const ArrayLww_1 = require("../../../types/lww-array/ArrayLww");
class Encoder extends msgpack_1.MsgPackEncoder {
    constructor() {
        super(new CrdtEncoder_1.CrdtWriter());
        this.clockEncoder = new ClockEncoder_1.ClockEncoder();
        this.time = 0;
        this.cTableEntry = (entry) => {
            const clock = entry.clock;
            this.writer.u53vu39(clock.sid, clock.time);
        };
        this.tsLogical = (ts) => {
            const relativeId = this.clockEncoder.append(ts);
            this.writer.id(relativeId.sessionIndex, relativeId.timeDiff);
        };
        this.tsServer = (ts) => {
            this.writer.vu57(ts.time);
        };
        this.ts = this.tsLogical;
        this.cKey = (val, key) => {
            this.encodeString(key);
            this.cNode(this.doc.index.get(val));
        };
    }
    encode(doc) {
        this.doc = doc;
        this.writer.reset();
        if (doc.clock.sid === 1)
            this.encodeServer(doc);
        else
            this.encodeLogical(doc);
        return this.writer.flush();
    }
    encodeLogical(model) {
        const writer = this.writer;
        this.ts = this.tsLogical;
        writer.u8(1);
        this.clockEncoder.reset(model.clock);
        writer.ensureCapacity(4);
        const x0 = writer.x0;
        const x = writer.x;
        writer.x += 4;
        this.cRoot(model.root);
        this.encodeClockTable(x0, x);
    }
    encodeServer(model) {
        this.ts = this.tsServer;
        this.writer.u8(0);
        this.writer.vu57((this.time = model.clock.time));
        this.cRoot(model.root);
    }
    encodeClockTable(x0, x) {
        const writer = this.writer;
        const shift = writer.x0 - x0;
        writer.view.setUint32(writer.x0 + (x - x0), writer.x - x - shift - 4);
        const clockEncoder = this.clockEncoder;
        const table = clockEncoder.table;
        const length = table.size;
        writer.vu39(length);
        table.forEach(this.cTableEntry);
    }
    cRoot(root) {
        const val = root.val;
        if (val.sid === 0)
            this.writer.u8(0);
        else
            this.cNode(root.node());
    }
    cNode(node) {
        if (node instanceof Const_1.Const)
            this.cConst(node);
        else if (node instanceof ValueLww_1.ValueLww)
            this.cVal(node);
        else if (node instanceof StringRga_1.StringRga)
            this.cStr(node);
        else if (node instanceof ObjectLww_1.ObjectLww)
            this.cObj(node);
        else if (node instanceof ArrayLww_1.ArrayLww)
            this.cTup(node);
        else if (node instanceof ArrayRga_1.ArrayRga)
            this.cArr(node);
        else if (node instanceof BinaryRga_1.BinaryRga)
            this.cBin(node);
    }
    cObj(obj) {
        this.ts(obj.id);
        this.encodeObjectHeader(obj.keys.size);
        obj.keys.forEach(this.cKey);
    }
    cTup(obj) {
        this.ts(obj.id);
        const elements = obj.elements;
        const length = elements.length;
        const writer = this.writer;
        writer.u8u16(0xc7, length << 8);
        const index = this.doc.index;
        for (let i = 0; i < length; i++) {
            const elementId = elements[i];
            if (!elementId)
                this.writer.u8(0);
            else
                this.cNode(index.get(elementId));
        }
    }
    cArr(obj) {
        const ts = this.ts;
        const writer = this.writer;
        ts(obj.id);
        this.encodeArrayHeader(obj.size());
        const index = this.doc.index;
        for (let chunk = obj.first(); chunk; chunk = obj.next(chunk)) {
            const span = chunk.span;
            const deleted = chunk.del;
            writer.b1vu28(deleted, span);
            ts(chunk.id);
            if (deleted)
                continue;
            const nodes = chunk.data;
            for (let i = 0; i < span; i++)
                this.cNode(index.get(nodes[i]));
        }
    }
    cStr(obj) {
        const ts = this.ts;
        const writer = this.writer;
        ts(obj.id);
        const length = obj.size();
        this.encodeStringHeader(length);
        for (let chunk = obj.first(); chunk; chunk = obj.next(chunk)) {
            ts(chunk.id);
            if (chunk.del) {
                writer.u8(0);
                writer.vu39(chunk.span);
            }
            else
                this.encodeString(chunk.data);
        }
    }
    cBin(obj) {
        const ts = this.ts;
        const writer = this.writer;
        ts(obj.id);
        const length = obj.size();
        this.encodeBinaryHeader(length);
        for (let chunk = obj.first(); chunk; chunk = obj.next(chunk)) {
            const length = chunk.span;
            const deleted = chunk.del;
            writer.b1vu28(chunk.del, length);
            ts(chunk.id);
            if (deleted)
                continue;
            writer.buf(chunk.data, length);
        }
    }
    cVal(obj) {
        this.ts(obj.id);
        this.writer.u8(0xd6);
        this.cNode(obj.node());
    }
    cConst(obj) {
        this.ts(obj.id);
        const val = obj.val;
        if (val instanceof clock_1.Timestamp) {
            this.writer.u8(0xd5);
            this.ts(val);
        }
        else {
            this.writer.u8(0xd4);
            this.writeAny(val);
        }
    }
}
exports.Encoder = Encoder;

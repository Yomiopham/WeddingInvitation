"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ViewDecoder = void 0;
const CrdtDecoder_1 = require("../../../../json-crdt-patch/util/binary/CrdtDecoder");
const msgpack_1 = require("../../../../json-pack/msgpack");
class ViewDecoder extends msgpack_1.MsgPackDecoderFast {
    constructor() {
        super(new CrdtDecoder_1.CrdtDecoder());
        this.time = -1;
    }
    decode(data) {
        const reader = this.reader;
        this.time = -1;
        reader.reset(data);
        const isServerTime = reader.u8() === 0;
        if (isServerTime) {
            this.time = reader.vu57();
        }
        else {
            reader.x += 4;
        }
        return this.cRoot();
    }
    ts() {
        if (this.time < 0)
            this.reader.idSkip();
        else
            this.reader.vu57Skip();
    }
    cRoot() {
        const reader = this.reader;
        const peek = reader.uint8[reader.x];
        return !peek ? undefined : this.cNode();
    }
    cNode() {
        const reader = this.reader;
        this.ts();
        const byte = reader.u8();
        if (byte <= 0b10001111)
            return this.cObj(byte & 0b1111);
        else if (byte <= 0b10011111)
            return this.cArr(byte & 0b1111);
        else if (byte <= 0b10111111)
            return this.cStr(byte & 0b11111);
        else {
            switch (byte) {
                case 0xc4:
                    return this.cBin(reader.u8());
                case 0xc5:
                    return this.cBin(reader.u16());
                case 0xc6:
                    return this.cBin(reader.u32());
                case 0xd4:
                    return this.val();
                case 0xd5:
                    return null;
                case 0xd6:
                    return this.cNode();
                case 0xde:
                    return this.cObj(reader.u16());
                case 0xdf:
                    return this.cObj(reader.u32());
                case 0xdc:
                    return this.cArr(reader.u16());
                case 0xdd:
                    return this.cArr(reader.u32());
                case 0xd9:
                    return this.cStr(reader.u8());
                case 0xda:
                    return this.cStr(reader.u16());
                case 0xdb:
                    return this.cStr(reader.u32());
                case 0xc7:
                    return this.cTup();
            }
        }
        return undefined;
    }
    cObj(length) {
        const obj = {};
        for (let i = 0; i < length; i++) {
            const key = this.key();
            const value = this.cNode();
            if (value !== undefined)
                obj[key] = value;
        }
        return obj;
    }
    cTup() {
        const reader = this.reader;
        const length = this.reader.u8();
        reader.x++;
        const obj = [];
        for (let i = 0; i < length; i++) {
            const octet = reader.peak();
            if (!octet) {
                reader.x++;
                obj.push(undefined);
            }
            else
                obj.push(this.cNode());
        }
        return obj;
    }
    cArr(length) {
        const arr = [];
        for (let i = 0; i < length; i++) {
            const values = this.cArrChunk();
            if (values && values.length)
                arr.push(...values);
        }
        return arr;
    }
    cArrChunk() {
        const [deleted, length] = this.reader.b1vu28();
        this.ts();
        if (deleted) {
            return undefined;
        }
        else {
            const values = [];
            for (let i = 0; i < length; i++)
                values.push(this.cNode());
            return values;
        }
    }
    cStr(length) {
        const reader = this.reader;
        let str = '';
        for (let i = 0; i < length; i++) {
            this.ts();
            const isTombstone = reader.uint8[reader.x] === 0;
            if (isTombstone) {
                reader.x++;
                reader.vu39Skip();
                continue;
            }
            const text = this.val();
            str += text;
        }
        return str;
    }
    cBin(length) {
        const reader = this.reader;
        const buffers = [];
        let totalLength = 0;
        for (let i = 0; i < length; i++) {
            const [deleted, length] = reader.b1vu28();
            this.ts();
            if (deleted)
                continue;
            buffers.push(reader.buf(length));
            totalLength += length;
        }
        const res = new Uint8Array(totalLength);
        let offset = 0;
        for (let i = 0; i < buffers.length; i++) {
            const byteLength = buffers[i].length;
            res.set(buffers[i], offset);
            offset += byteLength;
        }
        return res;
    }
}
exports.ViewDecoder = ViewDecoder;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cli = void 0;
const tslib_1 = require("tslib");
const node_util_1 = require("node:util");
const TypeRouter_1 = require("../json-type/system/TypeRouter");
const TypeRouterCaller_1 = require("../reactive-rpc/common/rpc/caller/TypeRouterCaller");
const bufferToUint8Array_1 = require("../util/buffers/bufferToUint8Array");
const json_patch_1 = require("../json-patch");
const util_1 = require("./util");
const json_pointer_1 = require("../json-pointer");
const methods_1 = require("./methods");
class Cli {
    constructor(options) {
        var _a;
        this.options = options;
        let router = (_a = options.router) !== null && _a !== void 0 ? _a : TypeRouter_1.TypeRouter.create();
        router = (0, methods_1.defineBuiltinRoutes)(router);
        this.router = router;
        this.caller = new TypeRouterCaller_1.TypeRouterCaller({ router, wrapInternalError: (err) => err });
        this.types = router.system;
        this.t = this.types.t;
        this.codecs = options.codecs;
    }
    run(options) {
        this.runAsync(options);
    }
    runAsync(options = {}) {
        var _a, _b, _c, _d, _e;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const argv = (_a = options.argv) !== null && _a !== void 0 ? _a : process.argv.slice(2);
            const stdin = (_b = options.stdin) !== null && _b !== void 0 ? _b : process.stdin;
            const stdout = (_c = options.stdout) !== null && _c !== void 0 ? _c : process.stdout;
            const stderr = (_d = options.stderr) !== null && _d !== void 0 ? _d : process.stderr;
            const exit = (_e = options.exit) !== null && _e !== void 0 ? _e : process.exit;
            const opts = { argv, stdin, stdout, stderr, exit };
            try {
                const args = (0, node_util_1.parseArgs)({
                    args: argv,
                    strict: false,
                    allowPositionals: true,
                });
                const methodName = args.positionals[0];
                if (args.values.v || args.values.version) {
                    this.printVersion(opts);
                    return;
                }
                if (args.values.h || args.values.help) {
                    this.printHelp(opts);
                    return;
                }
                let request = JSON.parse(args.positionals[1] || '{}');
                const _f = args.values, { f: format_ = '', format = format_, stdin: inPath_ = '', in: inPath = inPath_, stdout: outPath_ = '', out: outPath = outPath_ } = _f, params = tslib_1.__rest(_f, ["f", "format", "stdin", "in", "stdout", "out"]);
                if (inPath)
                    (0, json_pointer_1.validateJsonPointer)(inPath);
                if (outPath)
                    (0, json_pointer_1.validateJsonPointer)(outPath);
                const codecs = this.codecs.getCodecs(format);
                const [requestCodec, responseCodec] = codecs;
                request = yield this.ingestStdinInput(stdin, requestCodec, request, String(inPath));
                (0, util_1.ingestParams)(params, request);
                const ctx = {
                    cli: this,
                    run: opts,
                    codecs,
                };
                try {
                    const value = yield this.caller.call(methodName, request, ctx);
                    let response = value.data;
                    if (outPath)
                        response = (0, json_pointer_1.find)(response, (0, json_pointer_1.toPath)(String(outPath))).val;
                    const buf = responseCodec.encode(response);
                    stdout.write(buf);
                }
                catch (err) {
                    const error = (0, util_1.formatError)(err);
                    const buf = responseCodec.encode(error);
                    stderr.write(buf);
                    exit(1);
                }
            }
            catch (err) {
                const error = (0, util_1.formatError)(err);
                const buf = JSON.stringify(error);
                stderr.write(buf);
                exit(1);
            }
        });
    }
    ingestStdinInput(stdin, codec, request, path) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const input = yield this.getStdinValue(stdin, codec);
            if (input === undefined)
                return request;
            if (path) {
                const res = (0, json_patch_1.applyPatch)(request, [{ op: 'add', path, value: input }], { mutate: true });
                return res.doc;
            }
            if (typeof request === 'object') {
                if (typeof input === 'object')
                    return Object.assign(Object.assign({}, request), input);
                return Object.assign(Object.assign({}, request), { input });
            }
            return input;
        });
    }
    cmd() {
        var _a;
        return (_a = this.options.cmd) !== null && _a !== void 0 ? _a : '<cmd>';
    }
    printVersion(options) {
        var _a, _b;
        const version = (_a = this.options.version) !== null && _a !== void 0 ? _a : '0.0.0-unknown';
        const stdout = (_b = options.stdout) !== null && _b !== void 0 ? _b : process.stdout;
        stdout.write(version + '\n');
    }
    printHelp(options) {
        var _a;
        const methods = Object.keys(this.router.routes).sort();
        const methodLines = methods.map((m) => {
            const route = this.router.routes[m];
            const schema = route.getSchema();
            let line = `- "${m}"`;
            if (schema.title)
                line += ` - ${schema.title}`;
            return line;
        });
        const cmd = this.cmd();
        const codecLines = [...this.codecs.codecs.values()].map((codec) => `- "${codec.id}" - ${codec.description}`);
        const text = `
  JSON Type CLI uses request/response paradigm to execute CLI commands. Each
  command is identified by the <method> name. Each command receives a JSON
  object as the request payload and returns a JSON object as a response.

  Request payload is composed from the following sources: (1) command line
  second parameter; (2) STDIN input; (3) command line options.

  Response object is returned to STDOUT. A part of it can be extracted using
  the "--stdout" or "--out" option.

  Usage:

      ${cmd} <method> '<json>'
      echo '<json>' | ${cmd} <method>
      ${cmd} <method> --<type><pointer>=<value>

  Examples:

      ${cmd} .echo '{ "foo": 123 }'
      ${cmd} .echo --num/value=123
      ${cmd} .echo --json/value='{ "foo": 123 }' --out=/value
      echo '{ "foo": 123 }' | ${cmd} .echo
      ${cmd} .echo --s/foo=bar --format=cbor
      cat data.cbor | ${cmd} .echo --format=cbor:json
      ${cmd} .echo '{"foo": 123}' --f=cbor | ${cmd} .echo --f=cbor:tree

  Options:

  - "-h" or "--help" - Print this help.
  - "-v" or "--version" - Print version.
  - "--stdin" or "--in" - JSON pointer where to inject STDIN input.
  - "--stdout" or "--out" - JSON pointer of response value for STDOUT.
  - "--format" or "--f" - Codec format to use for encoding/decoding
    request/response values. To specify both request and response codecs use
    "<codec>", or "<reqCodec>:<resCodec>" to specify them separately.
    
    Available codecs:

    ${codecLines.join('\n    ')}

  Method help:

      ${cmd} .type --out=/<method>
      ${cmd} .type --out=/<method>/description
      ${cmd} .type --out=/<method>/req
      ${cmd} .type --out=/<method>/res --format=tree

  Methods:

  ${methodLines.join('\n  ')}

`;
        const stdout = (_a = options.stdout) !== null && _a !== void 0 ? _a : process.stdout;
        stdout.write(text);
    }
    getStdin(stdin) {
        var _a, stdin_1, stdin_1_1;
        var _b, e_1, _c, _d;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (stdin.isTTY)
                return Buffer.alloc(0);
            const result = [];
            let length = 0;
            try {
                for (_a = true, stdin_1 = tslib_1.__asyncValues(stdin); stdin_1_1 = yield stdin_1.next(), _b = stdin_1_1.done, !_b; _a = true) {
                    _d = stdin_1_1.value;
                    _a = false;
                    const chunk = _d;
                    result.push(chunk);
                    length += chunk.length;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_a && !_b && (_c = stdin_1.return)) yield _c.call(stdin_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return Buffer.concat(result, length);
        });
    }
    getStdinValue(stdin, codec) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (stdin.isTTY)
                return Object.create(null);
            const input = yield this.getStdin(stdin);
            if (codec.id === 'json') {
                const str = input.toString().trim();
                if (!str)
                    return Object.create(null);
            }
            const uint8 = (0, bufferToUint8Array_1.bufferToUint8Array)(input);
            return codec.decode(uint8);
        });
    }
}
exports.Cli = Cli;

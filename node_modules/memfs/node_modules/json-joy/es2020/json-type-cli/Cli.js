"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cli = void 0;
const node_util_1 = require("node:util");
const TypeRouter_1 = require("../json-type/system/TypeRouter");
const TypeRouterCaller_1 = require("../reactive-rpc/common/rpc/caller/TypeRouterCaller");
const bufferToUint8Array_1 = require("../util/buffers/bufferToUint8Array");
const json_patch_1 = require("../json-patch");
const util_1 = require("./util");
const json_pointer_1 = require("../json-pointer");
const methods_1 = require("./methods");
class Cli {
    constructor(options) {
        this.options = options;
        let router = options.router ?? TypeRouter_1.TypeRouter.create();
        router = (0, methods_1.defineBuiltinRoutes)(router);
        this.router = router;
        this.caller = new TypeRouterCaller_1.TypeRouterCaller({ router, wrapInternalError: (err) => err });
        this.types = router.system;
        this.t = this.types.t;
        this.codecs = options.codecs;
    }
    run(options) {
        this.runAsync(options);
    }
    async runAsync(options = {}) {
        const argv = options.argv ?? process.argv.slice(2);
        const stdin = options.stdin ?? process.stdin;
        const stdout = options.stdout ?? process.stdout;
        const stderr = options.stderr ?? process.stderr;
        const exit = options.exit ?? process.exit;
        const opts = { argv, stdin, stdout, stderr, exit };
        try {
            const args = (0, node_util_1.parseArgs)({
                args: argv,
                strict: false,
                allowPositionals: true,
            });
            const methodName = args.positionals[0];
            if (args.values.v || args.values.version) {
                this.printVersion(opts);
                return;
            }
            if (args.values.h || args.values.help) {
                this.printHelp(opts);
                return;
            }
            let request = JSON.parse(args.positionals[1] || '{}');
            const { f: format_ = '', format = format_, stdin: inPath_ = '', in: inPath = inPath_, stdout: outPath_ = '', out: outPath = outPath_, ...params } = args.values;
            if (inPath)
                (0, json_pointer_1.validateJsonPointer)(inPath);
            if (outPath)
                (0, json_pointer_1.validateJsonPointer)(outPath);
            const codecs = this.codecs.getCodecs(format);
            const [requestCodec, responseCodec] = codecs;
            request = await this.ingestStdinInput(stdin, requestCodec, request, String(inPath));
            (0, util_1.ingestParams)(params, request);
            const ctx = {
                cli: this,
                run: opts,
                codecs,
            };
            try {
                const value = await this.caller.call(methodName, request, ctx);
                let response = value.data;
                if (outPath)
                    response = (0, json_pointer_1.find)(response, (0, json_pointer_1.toPath)(String(outPath))).val;
                const buf = responseCodec.encode(response);
                stdout.write(buf);
            }
            catch (err) {
                const error = (0, util_1.formatError)(err);
                const buf = responseCodec.encode(error);
                stderr.write(buf);
                exit(1);
            }
        }
        catch (err) {
            const error = (0, util_1.formatError)(err);
            const buf = JSON.stringify(error);
            stderr.write(buf);
            exit(1);
        }
    }
    async ingestStdinInput(stdin, codec, request, path) {
        const input = await this.getStdinValue(stdin, codec);
        if (input === undefined)
            return request;
        if (path) {
            const res = (0, json_patch_1.applyPatch)(request, [{ op: 'add', path, value: input }], { mutate: true });
            return res.doc;
        }
        if (typeof request === 'object') {
            if (typeof input === 'object')
                return { ...request, ...input };
            return { ...request, input };
        }
        return input;
    }
    cmd() {
        return this.options.cmd ?? '<cmd>';
    }
    printVersion(options) {
        const version = this.options.version ?? '0.0.0-unknown';
        const stdout = options.stdout ?? process.stdout;
        stdout.write(version + '\n');
    }
    printHelp(options) {
        const methods = Object.keys(this.router.routes).sort();
        const methodLines = methods.map((m) => {
            const route = this.router.routes[m];
            const schema = route.getSchema();
            let line = `- "${m}"`;
            if (schema.title)
                line += ` - ${schema.title}`;
            return line;
        });
        const cmd = this.cmd();
        const codecLines = [...this.codecs.codecs.values()].map((codec) => `- "${codec.id}" - ${codec.description}`);
        const text = `
  JSON Type CLI uses request/response paradigm to execute CLI commands. Each
  command is identified by the <method> name. Each command receives a JSON
  object as the request payload and returns a JSON object as a response.

  Request payload is composed from the following sources: (1) command line
  second parameter; (2) STDIN input; (3) command line options.

  Response object is returned to STDOUT. A part of it can be extracted using
  the "--stdout" or "--out" option.

  Usage:

      ${cmd} <method> '<json>'
      echo '<json>' | ${cmd} <method>
      ${cmd} <method> --<type><pointer>=<value>

  Examples:

      ${cmd} .echo '{ "foo": 123 }'
      ${cmd} .echo --num/value=123
      ${cmd} .echo --json/value='{ "foo": 123 }' --out=/value
      echo '{ "foo": 123 }' | ${cmd} .echo
      ${cmd} .echo --s/foo=bar --format=cbor
      cat data.cbor | ${cmd} .echo --format=cbor:json
      ${cmd} .echo '{"foo": 123}' --f=cbor | ${cmd} .echo --f=cbor:tree

  Options:

  - "-h" or "--help" - Print this help.
  - "-v" or "--version" - Print version.
  - "--stdin" or "--in" - JSON pointer where to inject STDIN input.
  - "--stdout" or "--out" - JSON pointer of response value for STDOUT.
  - "--format" or "--f" - Codec format to use for encoding/decoding
    request/response values. To specify both request and response codecs use
    "<codec>", or "<reqCodec>:<resCodec>" to specify them separately.
    
    Available codecs:

    ${codecLines.join('\n    ')}

  Method help:

      ${cmd} .type --out=/<method>
      ${cmd} .type --out=/<method>/description
      ${cmd} .type --out=/<method>/req
      ${cmd} .type --out=/<method>/res --format=tree

  Methods:

  ${methodLines.join('\n  ')}

`;
        const stdout = options.stdout ?? process.stdout;
        stdout.write(text);
    }
    async getStdin(stdin) {
        if (stdin.isTTY)
            return Buffer.alloc(0);
        const result = [];
        let length = 0;
        for await (const chunk of stdin) {
            result.push(chunk);
            length += chunk.length;
        }
        return Buffer.concat(result, length);
    }
    async getStdinValue(stdin, codec) {
        if (stdin.isTTY)
            return Object.create(null);
        const input = await this.getStdin(stdin);
        if (codec.id === 'json') {
            const str = input.toString().trim();
            if (!str)
                return Object.create(null);
        }
        const uint8 = (0, bufferToUint8Array_1.bufferToUint8Array)(input);
        return codec.decode(uint8);
    }
}
exports.Cli = Cli;

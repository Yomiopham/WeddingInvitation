"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModelApi = void 0;
const nodes_1 = require("./nodes");
const PatchBuilder_1 = require("../../../json-crdt-patch/PatchBuilder");
const ArrayLww_1 = require("../../types/lww-array/ArrayLww");
const Const_1 = require("../../types/const/Const");
const ObjectLww_1 = require("../../types/lww-object/ObjectLww");
const ArrayRga_1 = require("../../types/rga-array/ArrayRga");
const BinaryRga_1 = require("../../types/rga-binary/BinaryRga");
const StringRga_1 = require("../../types/rga-string/StringRga");
const ValueLww_1 = require("../../types/lww-value/ValueLww");
class ModelApi {
    constructor(model) {
        this.model = model;
        this.next = 0;
        this.changeQueued = false;
        this.queueChange = () => {
            if (this.changeQueued)
                return;
            this.changeQueued = true;
            queueMicrotask(() => {
                this.changeQueued = false;
                const et = this.et;
                if (et)
                    et.dispatchEvent(new CustomEvent('change'));
            });
        };
        this.et = undefined;
        this.builder = new PatchBuilder_1.PatchBuilder(this.model.clock);
    }
    get events() {
        let et = this.et;
        if (!et) {
            this.et = et = new EventTarget();
            this.model.onchange = this.queueChange;
        }
        return et;
    }
    wrap(node) {
        if (node instanceof ValueLww_1.ValueLww)
            return node.api || (node.api = new nodes_1.ValueApi(node, this));
        else if (node instanceof StringRga_1.StringRga)
            return node.api || (node.api = new nodes_1.StringApi(node, this));
        else if (node instanceof BinaryRga_1.BinaryRga)
            return node.api || (node.api = new nodes_1.BinaryApi(node, this));
        else if (node instanceof ArrayRga_1.ArrayRga)
            return node.api || (node.api = new nodes_1.ArrayApi(node, this));
        else if (node instanceof ObjectLww_1.ObjectLww)
            return node.api || (node.api = new nodes_1.ObjectApi(node, this));
        else if (node instanceof Const_1.Const)
            return node.api || (node.api = new nodes_1.ConstApi(node, this));
        else if (node instanceof ArrayLww_1.ArrayLww)
            return node.api || (node.api = new nodes_1.TupleApi(node, this));
        else
            throw new Error('UNKNOWN_NODE');
    }
    get node() {
        return new nodes_1.NodeApi(this.model.root.node(), this);
    }
    get r() {
        return new nodes_1.NodeApi(this.model.root, this);
    }
    in(path) {
        return this.r.in(path);
    }
    find(path) {
        return this.node.find(path);
    }
    val(path) {
        return this.node.val(path);
    }
    tup(path) {
        return this.node.tup(path);
    }
    str(path) {
        return this.node.str(path);
    }
    bin(path) {
        return this.node.bin(path);
    }
    arr(path) {
        return this.node.arr(path);
    }
    obj(path) {
        return this.node.obj(path);
    }
    const(path) {
        return this.node.const(path);
    }
    root(json) {
        const builder = this.builder;
        builder.root(builder.json(json));
        this.apply();
        return this;
    }
    apply() {
        const ops = this.builder.patch.ops;
        const length = ops.length;
        const model = this.model;
        for (let i = this.next; i < length; i++)
            model.applyOperation(ops[i]);
        this.next = length;
        model.tick++;
        model.onchange?.();
    }
    advance() {
        this.next = this.builder.patch.ops.length;
        const model = this.model;
        model.tick++;
        model.onchange?.();
    }
    view() {
        return this.model.view();
    }
    flush() {
        const patch = this.builder.flush();
        this.next = 0;
        return patch;
    }
}
exports.ModelApi = ModelApi;

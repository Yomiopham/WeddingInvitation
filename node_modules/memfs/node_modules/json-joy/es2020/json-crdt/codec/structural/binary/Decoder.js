"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Decoder = void 0;
const ArrayRga_1 = require("../../../types/rga-array/ArrayRga");
const BinaryRga_1 = require("../../../types/rga-binary/BinaryRga");
const ClockDecoder_1 = require("../../../../json-crdt-patch/codec/clock/ClockDecoder");
const Const_1 = require("../../../types/const/Const");
const CrdtDecoder_1 = require("../../../../json-crdt-patch/util/binary/CrdtDecoder");
const clock_1 = require("../../../../json-crdt-patch/clock");
const model_1 = require("../../../model");
const msgpack_1 = require("../../../../json-pack/msgpack");
const ObjectLww_1 = require("../../../types/lww-object/ObjectLww");
const RootLww_1 = require("../../../types/lww-root/RootLww");
const StringRga_1 = require("../../../types/rga-string/StringRga");
const ValueLww_1 = require("../../../types/lww-value/ValueLww");
const ArrayLww_1 = require("../../../types/lww-array/ArrayLww");
class Decoder extends msgpack_1.MsgPackDecoderFast {
    constructor() {
        super(new CrdtDecoder_1.CrdtDecoder());
        this.time = -1;
        this.cArrChunk = () => {
            const [deleted, length] = this.reader.b1vu28();
            const id = this.ts();
            if (deleted)
                return new ArrayRga_1.ArrayChunk(id, length, undefined);
            const ids = [];
            for (let i = 0; i < length; i++)
                ids.push(this.cNode().id);
            return new ArrayRga_1.ArrayChunk(id, length, ids);
        };
        this.cStrChunk = () => {
            const reader = this.reader;
            const id = this.ts();
            const isTombstone = reader.uint8[reader.x] === 0;
            if (isTombstone) {
                reader.x++;
                const length = reader.vu39();
                return new StringRga_1.StringChunk(id, length, '');
            }
            const text = this.str();
            return new StringRga_1.StringChunk(id, text.length, text);
        };
        this.cBinChunk = () => {
            const reader = this.reader;
            const [deleted, length] = reader.b1vu28();
            const id = this.ts();
            if (deleted)
                return new BinaryRga_1.BinaryChunk(id, length, undefined);
            else
                return new BinaryRga_1.BinaryChunk(id, length, reader.buf(length));
        };
    }
    decode(data) {
        delete this.clockDecoder;
        this.time = -1;
        const reader = this.reader;
        reader.reset(data);
        const isServerTime = reader.u8() === 0;
        if (isServerTime) {
            const time = (this.time = reader.vu57());
            this.doc = model_1.Model.withServerClock(time);
        }
        else {
            this.decodeClockTable();
            const clock = this.clockDecoder.clock;
            this.doc = model_1.Model.withLogicalClock(clock);
        }
        this.doc.root = new RootLww_1.RootLww(this.doc, this.cRoot().id);
        delete this.clockDecoder;
        return this.doc;
    }
    decodeClockTable() {
        const reader = this.reader;
        const clockTableOffset = reader.u32();
        const offset = reader.x;
        reader.x += clockTableOffset;
        const length = reader.vu39();
        const [sessionId, time] = reader.u53vu39();
        this.clockDecoder = new ClockDecoder_1.ClockDecoder(sessionId, time);
        for (let i = 1; i < length; i++) {
            const [sid, time] = reader.u53vu39();
            this.clockDecoder.pushTuple(sid, time);
        }
        reader.x = offset;
    }
    ts() {
        const decoderTime = this.time;
        const isLogical = decoderTime < 0;
        if (isLogical) {
            const [sessionIndex, timeDiff] = this.reader.id();
            return this.clockDecoder.decodeId(sessionIndex, timeDiff);
        }
        else {
            return new clock_1.Timestamp(1, this.reader.vu57());
        }
    }
    cRoot() {
        const reader = this.reader;
        const peek = reader.uint8[reader.x];
        return !peek ? model_1.UNDEFINED : this.cNode();
    }
    cNode() {
        const reader = this.reader;
        const id = this.ts();
        const byte = reader.u8();
        if (byte <= 0b10001111)
            return this.cObj(id, byte & 0b1111);
        else if (byte <= 0b10011111)
            return this.cArr(id, byte & 0b1111);
        else if (byte <= 0b10111111)
            return this.cStr(id, byte & 0b11111);
        else {
            switch (byte) {
                case 0xc4:
                    return this.cBin(id, reader.u8());
                case 0xc5:
                    return this.cBin(id, reader.u16());
                case 0xc6:
                    return this.cBin(id, reader.u32());
                case 0xd4: {
                    const obj = new Const_1.Const(id, this.val());
                    this.doc.index.set(obj);
                    return obj;
                }
                case 0xd5: {
                    const obj = new Const_1.Const(id, this.ts());
                    this.doc.index.set(obj);
                    return obj;
                }
                case 0xd6: {
                    const val = this.cNode();
                    const obj = new ValueLww_1.ValueLww(this.doc, id, val.id);
                    this.doc.index.set(obj);
                    return obj;
                }
                case 0xde:
                    return this.cObj(id, reader.u16());
                case 0xdf:
                    return this.cObj(id, reader.u32());
                case 0xdc:
                    return this.cArr(id, reader.u16());
                case 0xdd:
                    return this.cArr(id, reader.u32());
                case 0xd9:
                    return this.cStr(id, reader.u8());
                case 0xda:
                    return this.cStr(id, reader.u16());
                case 0xdb:
                    return this.cStr(id, reader.u32());
                case 0xc7:
                    return this.cTup(id);
            }
        }
        throw new Error('UNKNOWN_NODE');
    }
    cObj(id, length) {
        const obj = new ObjectLww_1.ObjectLww(this.doc, id);
        for (let i = 0; i < length; i++)
            this.cObjChunk(obj);
        this.doc.index.set(obj);
        return obj;
    }
    cObjChunk(obj) {
        const key = this.key();
        obj.keys.set(key, this.cNode().id);
    }
    cTup(id) {
        const reader = this.reader;
        const length = this.reader.u8();
        reader.x++;
        const obj = new ArrayLww_1.ArrayLww(this.doc, id);
        const elements = obj.elements;
        for (let i = 0; i < length; i++) {
            const octet = reader.peak();
            if (!octet) {
                reader.x++;
                elements.push(undefined);
            }
            else
                elements.push(this.cNode().id);
        }
        this.doc.index.set(obj);
        return obj;
    }
    cArr(id, length) {
        const obj = new ArrayRga_1.ArrayRga(this.doc, id);
        obj.ingest(length, this.cArrChunk);
        this.doc.index.set(obj);
        return obj;
    }
    cStr(id, length) {
        const node = new StringRga_1.StringRga(id);
        if (length)
            node.ingest(length, this.cStrChunk);
        this.doc.index.set(node);
        return node;
    }
    cBin(id, length) {
        const node = new BinaryRga_1.BinaryRga(id);
        if (length)
            node.ingest(length, this.cBinChunk);
        this.doc.index.set(node);
        return node;
    }
}
exports.Decoder = Decoder;

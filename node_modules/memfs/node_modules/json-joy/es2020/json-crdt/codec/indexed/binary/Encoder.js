"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Encoder = void 0;
const clock_1 = require("../../../../json-crdt-patch/clock");
const ClockTable_1 = require("../../../../json-crdt-patch/codec/clock/ClockTable");
const CrdtEncoder_1 = require("../../../../json-crdt-patch/util/binary/CrdtEncoder");
const msgpack_1 = require("../../../../json-pack/msgpack");
const Const_1 = require("../../../types/const/Const");
const ObjectLww_1 = require("../../../types/lww-object/ObjectLww");
const ValueLww_1 = require("../../../types/lww-value/ValueLww");
const ArrayRga_1 = require("../../../types/rga-array/ArrayRga");
const BinaryRga_1 = require("../../../types/rga-binary/BinaryRga");
const StringRga_1 = require("../../../types/rga-string/StringRga");
const EMPTY = new Uint8Array(0);
class Encoder {
    constructor() {
        this.enc = new msgpack_1.MsgPackEncoder(new CrdtEncoder_1.CrdtWriter());
        this.onNode = (map, sid) => {
            const model = this.model;
            const sidIndex = this.clockTable.getBySid(sid).index;
            const sidFieldPart = sidIndex.toString(36) + '_';
            map.forEach((node, time) => {
                const field = (sidFieldPart + time.toString(36));
                model[field] = this.encodeNode(node);
            });
        };
        this.onObjectKey = (value, key) => {
            this.enc.writeStr(key);
            this.ts(value);
        };
    }
    encode(doc, clockTable = ClockTable_1.ClockTable.from(doc.clock)) {
        this.clockTable = clockTable;
        const writer = this.enc.writer;
        writer.reset();
        clockTable.write(writer);
        const encodedClock = writer.flush();
        const rootValueId = doc.root.val;
        const model = (this.model = {
            c: encodedClock,
        });
        if (rootValueId.sid !== 0) {
            writer.reset();
            this.ts(rootValueId);
            model.r = writer.flush();
        }
        doc.index.entries.forEach(this.onNode);
        return model;
    }
    encodeNode(node) {
        if (node instanceof ValueLww_1.ValueLww)
            return this.encodeVal(node);
        else if (node instanceof Const_1.Const)
            return this.encodeConst(node);
        else if (node instanceof StringRga_1.StringRga)
            return this.encodeStr(node);
        else if (node instanceof ObjectLww_1.ObjectLww)
            return this.encodeObj(node);
        else if (node instanceof ArrayRga_1.ArrayRga)
            return this.encodeArr(node);
        else if (node instanceof BinaryRga_1.BinaryRga)
            return this.encodeBin(node);
        else
            return EMPTY;
    }
    ts(id) {
        const index = this.clockTable.getBySid(id.sid).index;
        this.enc.writer.id(index, id.time);
    }
    encodeVal(node) {
        const writer = this.enc.writer;
        const child = node.node();
        writer.reset();
        writer.u8(0xd6);
        this.ts(child.id);
        return writer.flush();
    }
    encodeConst(node) {
        const encoder = this.enc;
        const writer = encoder.writer;
        const val = node.val;
        writer.reset();
        if (val instanceof clock_1.Timestamp) {
            writer.u8(0xd5);
            this.ts(val);
        }
        else {
            writer.u8(0xd4);
            encoder.writeAny(node.val);
        }
        return writer.flush();
    }
    encodeStr(node) {
        const encoder = this.enc;
        const writer = encoder.writer;
        writer.reset();
        encoder.writeStrHdr(node.size());
        for (let chunk = node.first(); chunk; chunk = node.next(chunk)) {
            this.ts(chunk.id);
            if (chunk.del)
                encoder.u32(chunk.span);
            else
                encoder.encodeString(chunk.data);
        }
        return writer.flush();
    }
    encodeBin(node) {
        const encoder = this.enc;
        const writer = encoder.writer;
        writer.reset();
        encoder.writeBinHdr(node.size());
        for (let chunk = node.first(); chunk; chunk = node.next(chunk)) {
            this.ts(chunk.id);
            const deleted = chunk.del;
            const length = chunk.span;
            writer.b1vu28(deleted, length);
            if (deleted)
                continue;
            writer.buf(chunk.data, length);
        }
        return writer.flush();
    }
    encodeObj(node) {
        const encoder = this.enc;
        const writer = encoder.writer;
        writer.reset();
        encoder.writeObjHdr(node.keys.size);
        node.keys.forEach(this.onObjectKey);
        return writer.flush();
    }
    encodeArr(node) {
        const encoder = this.enc;
        const writer = encoder.writer;
        writer.reset();
        encoder.writeArrHdr(node.size());
        for (let chunk = node.first(); chunk; chunk = node.next(chunk)) {
            const length = chunk.span;
            const deleted = chunk.del;
            this.ts(chunk.id);
            writer.b1vu28(deleted, length);
            if (deleted)
                continue;
            const data = chunk.data;
            for (let i = 0; i < length; i++)
                this.ts(data[i]);
        }
        return writer.flush();
    }
}
exports.Encoder = Encoder;

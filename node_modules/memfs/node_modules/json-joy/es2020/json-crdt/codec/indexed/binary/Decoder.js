"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Decoder = void 0;
const ArrayRga_1 = require("../../../types/rga-array/ArrayRga");
const BinaryRga_1 = require("../../../types/rga-binary/BinaryRga");
const ClockTable_1 = require("../../../../json-crdt-patch/codec/clock/ClockTable");
const Const_1 = require("../../../types/const/Const");
const CrdtDecoder_1 = require("../../../../json-crdt-patch/util/binary/CrdtDecoder");
const clock_1 = require("../../../../json-crdt-patch/clock");
const model_1 = require("../../../model");
const msgpack_1 = require("../../../../json-pack/msgpack");
const ObjectLww_1 = require("../../../types/lww-object/ObjectLww");
const StringRga_1 = require("../../../types/rga-string/StringRga");
const ValueLww_1 = require("../../../types/lww-value/ValueLww");
class Decoder {
    constructor() {
        this.dec = new msgpack_1.MsgPackDecoderFast(new CrdtDecoder_1.CrdtDecoder());
    }
    decode(fields, ModelConstructor = model_1.Model) {
        const reader = this.dec.reader;
        reader.reset(fields.c);
        const clockTable = (this.clockTable = ClockTable_1.ClockTable.decode(reader));
        return this.decodeFields(clockTable, fields, ModelConstructor);
    }
    decodeFields(clockTable, fields, ModelConstructor = model_1.Model) {
        const reader = this.dec.reader;
        const firstClock = clockTable.byIdx[0];
        const vectorClock = new clock_1.VectorClock(firstClock.sid, firstClock.time + 1);
        const doc = (this.doc = new ModelConstructor(vectorClock));
        const root = fields.r;
        if (root && root.length) {
            reader.reset(root);
            const rootValue = this.ts();
            doc.root.set(rootValue);
        }
        const docIndex = doc.index;
        for (const field in fields) {
            if (field.length < 3)
                continue;
            const arr = fields[field];
            const id = clockTable.parseField(field);
            reader.reset(arr);
            const node = this.decodeNode(id);
            docIndex.set(node);
        }
        return doc;
    }
    ts() {
        const [sessionIndex, timeDiff] = this.dec.reader.id();
        return new clock_1.Timestamp(this.clockTable.byIdx[sessionIndex].sid, timeDiff);
    }
    decodeNode(id) {
        const reader = this.dec.reader;
        const byte = reader.u8();
        if (byte <= 0b10001111)
            return this.cObj(id, byte & 0b1111);
        else if (byte <= 0b10011111)
            return this.cArr(id, byte & 0b1111);
        else if (byte <= 0b10111111)
            return this.cStr(id, byte & 0b11111);
        else {
            switch (byte) {
                case 0xc4:
                    return this.cBin(id, reader.u8());
                case 0xc5:
                    return this.cBin(id, reader.u16());
                case 0xc6:
                    return this.cBin(id, reader.u32());
                case 0xd4:
                    return this.cConst(id);
                case 0xd5:
                    return new Const_1.Const(id, this.ts());
                case 0xd6:
                    return this.cVal(id);
                case 0xde:
                    return this.cObj(id, reader.u16());
                case 0xdf:
                    return this.cObj(id, reader.u32());
                case 0xdc:
                    return this.cArr(id, reader.u16());
                case 0xdd:
                    return this.cArr(id, reader.u32());
                case 0xd9:
                    return this.cStr(id, reader.u8());
                case 0xda:
                    return this.cStr(id, reader.u16());
                case 0xdb:
                    return this.cStr(id, reader.u32());
            }
        }
        return model_1.UNDEFINED;
    }
    cConst(id) {
        const val = this.dec.val();
        return new Const_1.Const(id, val);
    }
    cVal(id) {
        const val = this.ts();
        return new ValueLww_1.ValueLww(this.doc, id, val);
    }
    cObj(id, length) {
        const decoder = this.dec;
        const obj = new ObjectLww_1.ObjectLww(this.doc, id);
        const keys = obj.keys;
        for (let i = 0; i < length; i++) {
            const key = String(decoder.val());
            const val = this.ts();
            keys.set(key, val);
        }
        return obj;
    }
    cStr(id, length) {
        const decoder = this.dec;
        const node = new StringRga_1.StringRga(id);
        node.ingest(length, () => {
            const chunkId = this.ts();
            const val = decoder.val();
            if (typeof val === 'number')
                return new StringRga_1.StringChunk(chunkId, val, '');
            const data = String(val);
            return new StringRga_1.StringChunk(chunkId, data.length, data);
        });
        return node;
    }
    cBin(id, length) {
        const decoder = this.dec;
        const reader = decoder.reader;
        const node = new BinaryRga_1.BinaryRga(id);
        node.ingest(length, () => {
            const chunkId = this.ts();
            const [deleted, length] = reader.b1vu28();
            if (deleted)
                return new BinaryRga_1.BinaryChunk(chunkId, length, undefined);
            const data = reader.buf(length);
            return new BinaryRga_1.BinaryChunk(chunkId, length, data);
        });
        return node;
    }
    cArr(id, length) {
        const decoder = this.dec;
        const reader = decoder.reader;
        const node = new ArrayRga_1.ArrayRga(this.doc, id);
        node.ingest(length, () => {
            const chunkId = this.ts();
            const [deleted, length] = reader.b1vu28();
            if (deleted)
                return new ArrayRga_1.ArrayChunk(chunkId, length, undefined);
            const data = [];
            for (let i = 0; i < length; i++)
                data.push(this.ts());
            return new ArrayRga_1.ArrayChunk(chunkId, length, data);
        });
        return node;
    }
}
exports.Decoder = Decoder;

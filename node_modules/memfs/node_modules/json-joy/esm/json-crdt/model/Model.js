import { NewConOp, NewObjOp, NewValOp, NewVecOp, NewStrOp, NewBinOp, NewArrOp, InsValOp, InsObjOp, InsVecOp, InsStrOp, InsBinOp, InsArrOp, DelOp, } from '../../json-crdt-patch/operations';
import { ArrayRga } from '../types/rga-array/ArrayRga';
import { BinaryRga } from '../types/rga-binary/BinaryRga';
import { Const } from '../types/const/Const';
import { encoder, decoder } from '../codec/structural/binary/shared';
import { Timestamp, VectorClock, ServerVectorClock } from '../../json-crdt-patch/clock';
import { ModelApi } from './api/ModelApi';
import { NodeIndex } from './NodeIndex';
import { ObjectLww } from '../types/lww-object/ObjectLww';
import { ORIGIN } from '../../json-crdt-patch/constants';
import { randomSessionId } from './util';
import { RootLww } from '../types/lww-root/RootLww';
import { StringRga } from '../types/rga-string/StringRga';
import { ValueLww } from '../types/lww-value/ValueLww';
import { ArrayLww } from '../types/lww-array/ArrayLww';
import { printTree } from '../../util/print/printTree';
import { Extensions } from '../extensions/Extensions';
export const UNDEFINED = new Const(ORIGIN, undefined);
export class Model {
    static withLogicalClock(clockOrSessionId) {
        const clock = typeof clockOrSessionId === 'number'
            ? new VectorClock(clockOrSessionId, 1)
            : clockOrSessionId || new VectorClock(randomSessionId(), 1);
        return new Model(clock);
    }
    static withServerClock(time = 0) {
        const clock = new ServerVectorClock(1, time);
        return new Model(clock);
    }
    static fromBinary(data) {
        return decoder.decode(data);
    }
    root = new RootLww(this, ORIGIN);
    clock;
    index = new NodeIndex();
    ext = new Extensions();
    constructor(clock) {
        this.clock = clock;
        if (!clock.time)
            clock.time = 1;
    }
    _api;
    get api() {
        if (!this._api)
            this._api = new ModelApi(this);
        return this._api;
    }
    tick = 0;
    onchange = undefined;
    applyBatch(patches) {
        const length = patches.length;
        for (let i = 0; i < length; i++)
            this.applyPatch(patches[i]);
    }
    applyPatch(patch) {
        const ops = patch.ops;
        const { length } = ops;
        for (let i = 0; i < length; i++)
            this.applyOperation(ops[i]);
        this.tick++;
        this.onchange?.();
    }
    applyOperation(op) {
        this.clock.observe(op.id, op.span());
        const index = this.index;
        if (op instanceof InsStrOp) {
            const node = index.get(op.obj);
            if (node instanceof StringRga)
                node.ins(op.ref, op.id, op.data);
        }
        else if (op instanceof NewObjOp) {
            if (!index.get(op.id))
                index.set(new ObjectLww(this, op.id));
        }
        else if (op instanceof NewArrOp) {
            if (!index.get(op.id))
                index.set(new ArrayRga(this, op.id));
        }
        else if (op instanceof NewStrOp) {
            if (!index.get(op.id))
                index.set(new StringRga(op.id));
        }
        else if (op instanceof NewValOp) {
            if (!index.get(op.id)) {
                const val = index.get(op.val);
                if (val)
                    index.set(new ValueLww(this, op.id, op.val));
            }
        }
        else if (op instanceof NewConOp) {
            if (!index.get(op.id))
                index.set(new Const(op.id, op.val));
        }
        else if (op instanceof InsObjOp) {
            const node = index.get(op.obj);
            const tuples = op.data;
            const length = tuples.length;
            if (node instanceof ObjectLww) {
                for (let i = 0; i < length; i++) {
                    const tuple = tuples[i];
                    const valueNode = index.get(tuple[1]);
                    if (!valueNode)
                        continue;
                    if (node.id.time >= tuple[1].time)
                        continue;
                    const old = node.put(tuple[0] + '', valueNode.id);
                    if (old)
                        this.deleteNodeTree(old);
                }
            }
        }
        else if (op instanceof InsVecOp) {
            const node = index.get(op.obj);
            const tuples = op.data;
            const length = tuples.length;
            if (node instanceof ArrayLww) {
                for (let i = 0; i < length; i++) {
                    const tuple = tuples[i];
                    const valueNode = index.get(tuple[1]);
                    if (!valueNode)
                        continue;
                    if (node.id.time >= tuple[1].time)
                        continue;
                    const old = node.put(Number(tuple[0]), valueNode.id);
                    if (old)
                        this.deleteNodeTree(old);
                }
            }
        }
        else if (op instanceof InsValOp) {
            const obj = op.obj;
            const node = obj.sid === 0 && obj.time === 0 ? this.root : index.get(obj);
            if (node instanceof ValueLww) {
                const newValue = index.get(op.val);
                if (newValue) {
                    const old = node.set(op.val);
                    if (old)
                        this.deleteNodeTree(old);
                }
            }
        }
        else if (op instanceof InsArrOp) {
            const node = index.get(op.obj);
            if (node instanceof ArrayRga) {
                const nodes = [];
                const data = op.data;
                const length = data.length;
                for (let i = 0; i < length; i++) {
                    const stamp = data[i];
                    const valueNode = index.get(stamp);
                    if (!valueNode)
                        continue;
                    if (node.id.time >= stamp.time)
                        continue;
                    nodes.push(stamp);
                }
                if (nodes.length)
                    node.ins(op.ref, op.id, nodes);
            }
        }
        else if (op instanceof DelOp) {
            const node = index.get(op.obj);
            if (node instanceof ArrayRga) {
                const length = op.what.length;
                for (let i = 0; i < length; i++) {
                    const span = op.what[i];
                    for (let j = 0; j < span.span; j++) {
                        const id = node.getById(new Timestamp(span.sid, span.time + j));
                        if (id)
                            this.deleteNodeTree(id);
                    }
                }
                node.delete(op.what);
            }
            else if (node instanceof StringRga)
                node.delete(op.what);
            else if (node instanceof BinaryRga)
                node.delete(op.what);
        }
        else if (op instanceof NewBinOp) {
            if (!index.get(op.id))
                index.set(new BinaryRga(op.id));
        }
        else if (op instanceof InsBinOp) {
            const node = index.get(op.obj);
            if (node instanceof BinaryRga)
                node.ins(op.ref, op.id, op.data);
        }
        else if (op instanceof NewVecOp) {
            if (!index.get(op.id))
                index.set(new ArrayLww(this, op.id));
        }
    }
    deleteNodeTree(value) {
        const isSystemNode = value.sid === 0;
        if (isSystemNode)
            return;
        const node = this.index.get(value);
        if (!node)
            return;
        node.children((child) => this.deleteNodeTree(child.id));
        this.index.delete(value);
    }
    fork(sessionId = randomSessionId()) {
        const copy = Model.fromBinary(this.toBinary());
        if (copy.clock.sid !== sessionId && copy.clock instanceof VectorClock)
            copy.clock = copy.clock.fork(sessionId);
        copy.ext = this.ext;
        return copy;
    }
    clone() {
        return this.fork(this.clock.sid);
    }
    view() {
        return this.root.view();
    }
    toString(tab = '') {
        const nl = () => '';
        const hasExtensions = this.ext.size() > 0;
        return (this.constructor.name +
            printTree(tab, [
                (tab) => this.root.toString(tab),
                nl,
                (tab) => this.index.toString(tab),
                nl,
                (tab) => this.clock.toString(tab),
                hasExtensions ? nl : null,
                hasExtensions ? (tab) => this.ext.toString(tab) : null,
            ]));
    }
    toBinary() {
        return encoder.encode(this);
    }
}

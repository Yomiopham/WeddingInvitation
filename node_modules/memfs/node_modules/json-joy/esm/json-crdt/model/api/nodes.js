import { ArrayRga } from '../../types/rga-array/ArrayRga';
import { BinaryRga } from '../../types/rga-binary/BinaryRga';
import { Const } from '../../types/const/Const';
import { find } from './find';
import { Timestamp } from '../../../json-crdt-patch/clock';
import { ObjectLww } from '../../types/lww-object/ObjectLww';
import { StringRga } from '../../types/rga-string/StringRga';
import { ValueLww } from '../../types/lww-value/ValueLww';
import { ArrayLww } from '../../types/lww-array/ArrayLww';
import { NodeEvents } from './events/NodeEvents';
export class NodeApi {
    node;
    api;
    constructor(node, api) {
        this.node = node;
        this.api = api;
    }
    ev = undefined;
    get events() {
        const et = this.ev;
        return et || (this.ev = new NodeEvents(this));
    }
    find(path) {
        const node = this.node;
        if (path === undefined) {
            if (typeof node.child === 'function') {
                const child = node.child();
                if (!child)
                    throw new Error('NO_CHILD');
                return child;
            }
            throw new Error('CANNOT_IN');
        }
        if (typeof path === 'string' && !!path && path[0] !== '/')
            path = '/' + path;
        if (typeof path === 'number')
            path = [path];
        return find(this.node, path);
    }
    in(path) {
        const node = this.find(path);
        return this.api.wrap(node);
    }
    asVal() {
        if (this.node instanceof ValueLww)
            return this.api.wrap(this.node);
        throw new Error('NOT_VAL');
    }
    asStr() {
        if (this.node instanceof StringRga)
            return this.api.wrap(this.node);
        throw new Error('NOT_STR');
    }
    asBin() {
        if (this.node instanceof BinaryRga)
            return this.api.wrap(this.node);
        throw new Error('NOT_BIN');
    }
    asArr() {
        if (this.node instanceof ArrayRga)
            return this.api.wrap(this.node);
        throw new Error('NOT_ARR');
    }
    asTup() {
        if (this.node instanceof ArrayLww)
            return this.api.wrap(this.node);
        throw new Error('NOT_ARR');
    }
    asObj() {
        if (this.node instanceof ObjectLww)
            return this.api.wrap(this.node);
        throw new Error('NOT_OBJ');
    }
    asConst() {
        if (this.node instanceof Const)
            return this.api.wrap(this.node);
        throw new Error('NOT_CONST');
    }
    asExt(ext) {
        let node = this.node;
        while (node) {
            if (node instanceof ext.Node)
                return new ext.Api(node, this.api);
            node = node.child ? node.child() : undefined;
        }
        throw new Error('NOT_EXT');
    }
    val(path) {
        return this.in(path).asVal();
    }
    str(path) {
        return this.in(path).asStr();
    }
    bin(path) {
        return this.in(path).asBin();
    }
    arr(path) {
        return this.in(path).asArr();
    }
    tup(path) {
        return this.in(path).asTup();
    }
    obj(path) {
        return this.in(path).asObj();
    }
    const(path) {
        return this.in(path).asConst();
    }
    view() {
        return this.node.view();
    }
}
export class ArrayApi extends NodeApi {
    ins(index, values) {
        const { api, node } = this;
        const { builder } = api;
        const after = !index ? node.id : node.find(index - 1);
        if (!after)
            throw new Error('OUT_OF_BOUNDS');
        const valueIds = [];
        for (let i = 0; i < values.length; i++)
            valueIds.push(builder.json(values[i]));
        builder.insArr(node.id, after, valueIds);
        api.apply();
        return this;
    }
    del(index, length) {
        const { api, node } = this;
        const spans = node.findInterval(index, length);
        if (!spans)
            throw new Error('OUT_OF_BOUNDS');
        api.builder.del(node.id, spans);
        api.apply();
        return this;
    }
    length() {
        return this.node.length();
    }
}
export class TupleApi extends NodeApi {
    set(entries) {
        const { api, node } = this;
        const { builder } = api;
        builder.insVec(node.id, entries.map(([index, json]) => [index, builder.constOrJson(json)]));
        api.apply();
        return this;
    }
}
export class BinaryApi extends NodeApi {
    ins(index, data) {
        const { api, node } = this;
        const after = !index ? node.id : node.find(index - 1);
        if (!after)
            throw new Error('OUT_OF_BOUNDS');
        api.builder.insBin(node.id, after, data);
        api.apply();
        return this;
    }
    del(index, length) {
        const { api, node } = this;
        const spans = node.findInterval(index, length);
        if (!spans)
            throw new Error('OUT_OF_BOUNDS');
        api.builder.del(node.id, spans);
        api.apply();
        return this;
    }
}
export class ConstApi extends NodeApi {
    view() {
        return this.node.view();
    }
}
export class ObjectApi extends NodeApi {
    set(entries) {
        const { api, node } = this;
        const { builder } = api;
        builder.setKeys(node.id, Object.entries(entries).map(([key, json]) => [key, builder.constOrJson(json)]));
        api.apply();
        return this;
    }
    del(keys) {
        const { api, node } = this;
        const { builder } = api;
        api.builder.setKeys(node.id, keys.map((key) => [key, builder.const(undefined)]));
        api.apply();
        return this;
    }
}
export class StringApi extends NodeApi {
    ins(index, text) {
        const { api, node } = this;
        const builder = api.builder;
        builder.pad();
        const nextTime = api.builder.nextTime();
        const id = new Timestamp(builder.clock.sid, nextTime);
        const after = node.insAt(index, id, text);
        if (!after)
            throw new Error('OUT_OF_BOUNDS');
        builder.insStr(node.id, after, text);
        api.advance();
        return this;
    }
    del(index, length) {
        const { api, node } = this;
        const builder = api.builder;
        builder.pad();
        const spans = node.findInterval(index, length);
        if (!spans)
            throw new Error('OUT_OF_BOUNDS');
        node.delete(spans);
        builder.del(node.id, spans);
        api.advance();
        return this;
    }
}
export class ValueApi extends NodeApi {
    set(json) {
        const { api, node } = this;
        const builder = api.builder;
        const val = builder.constOrJson(json);
        api.builder.setVal(node.id, val);
        api.apply();
        return this;
    }
}

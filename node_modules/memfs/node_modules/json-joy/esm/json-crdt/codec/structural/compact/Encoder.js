import { ArrayRga } from '../../../types/rga-array/ArrayRga';
import { BinaryRga } from '../../../types/rga-binary/BinaryRga';
import { ClockEncoder } from '../../../../json-crdt-patch/codec/clock/ClockEncoder';
import { Const } from '../../../types/const/Const';
import { Timestamp } from '../../../../json-crdt-patch/clock';
import { ObjectLww } from '../../../types/lww-object/ObjectLww';
import { StringRga } from '../../../types/rga-string/StringRga';
import { ValueLww } from '../../../types/lww-value/ValueLww';
import { ArrayLww } from '../../../types/lww-array/ArrayLww';
export class Encoder {
    time;
    clock;
    model;
    encode(model) {
        this.model = model;
        const isServerTime = model.clock.sid === 1;
        const clock = model.clock;
        const arr = isServerTime ? [clock.time] : [null];
        if (isServerTime) {
            this.time = clock.time;
        }
        else {
            this.clock = new ClockEncoder();
            this.clock.reset(model.clock);
        }
        this.encodeRoot(arr, model.root);
        if (!isServerTime)
            arr[0] = this.clock.toJson();
        return arr;
    }
    ts(arr, ts) {
        switch (ts.sid) {
            case 0: {
                arr.push([ts.time]);
                break;
            }
            case 1: {
                arr.push(this.time - ts.time);
                break;
            }
            default: {
                const relativeId = this.clock.append(ts);
                arr.push(-relativeId.sessionIndex, relativeId.timeDiff);
            }
        }
    }
    encodeRoot(arr, root) {
        if (!root.val.time)
            arr.push(0);
        else
            this.cNode(arr, root.node());
    }
    cNode(arr, node) {
        if (node instanceof ObjectLww)
            return this.encodeObj(arr, node);
        else if (node instanceof ArrayRga)
            return this.encodeArr(arr, node);
        else if (node instanceof StringRga)
            return this.encodeStr(arr, node);
        else if (node instanceof ValueLww)
            return this.cVal(arr, node);
        else if (node instanceof ArrayLww)
            return this.cTup(arr, node);
        else if (node instanceof Const)
            return this.cConst(arr, node);
        else if (node instanceof BinaryRga)
            return this.encodeBin(arr, node);
        throw new Error('UNKNOWN_NODE');
    }
    encodeObj(arr, obj) {
        const res = [3];
        arr.push(res);
        this.ts(res, obj.id);
        obj.nodes((node, key) => {
            res.push(key);
            this.cNode(res, node);
        });
    }
    cTup(arr, obj) {
        const res = [7];
        arr.push(res);
        this.ts(res, obj.id);
        const elements = obj.elements;
        const length = elements.length;
        const index = this.model.index;
        for (let i = 0; i < length; i++) {
            const elementId = elements[i];
            if (!elementId)
                res.push(0);
            else {
                const node = index.get(elementId);
                this.cNode(res, node);
            }
        }
    }
    encodeArr(arr, obj) {
        const res = [5, obj.size()];
        arr.push(res);
        this.ts(res, obj.id);
        const iterator = obj.iterator();
        let chunk;
        while ((chunk = iterator()))
            this.encodeArrChunk(res, chunk);
    }
    encodeArrChunk(arr, chunk) {
        this.ts(arr, chunk.id);
        if (chunk.del)
            arr.push(chunk.span);
        else {
            const nodes = [];
            const index = this.model.index;
            for (const n of chunk.data)
                this.cNode(nodes, index.get(n));
            arr.push(nodes);
        }
    }
    encodeStr(arr, obj) {
        const res = [4, obj.size()];
        arr.push(res);
        this.ts(res, obj.id);
        const iterator = obj.iterator();
        let chunk;
        while ((chunk = iterator()))
            this.encodeStrChunk(res, chunk);
    }
    encodeStrChunk(arr, chunk) {
        this.ts(arr, chunk.id);
        arr.push(chunk.del ? chunk.span : chunk.data);
    }
    encodeBin(arr, obj) {
        const res = [6, obj.size()];
        arr.push(res);
        this.ts(res, obj.id);
        const iterator = obj.iterator();
        let chunk;
        while ((chunk = iterator()))
            this.encodeBinChunk(res, chunk);
    }
    encodeBinChunk(arr, chunk) {
        this.ts(arr, chunk.id);
        arr.push(chunk.del ? chunk.span : chunk.data);
    }
    cVal(arr, obj) {
        const res = [2];
        arr.push(res);
        this.ts(res, obj.id);
        this.cNode(res, obj.node());
    }
    cConst(arr, obj) {
        const val = obj.val;
        const res = [];
        if (val instanceof Timestamp) {
            res.push(8);
            this.ts(res, obj.id);
            this.ts(res, val);
        }
        else {
            res.push(1);
            this.ts(res, obj.id);
            if (val !== undefined)
                res.push(val);
        }
        arr.push(res);
    }
}

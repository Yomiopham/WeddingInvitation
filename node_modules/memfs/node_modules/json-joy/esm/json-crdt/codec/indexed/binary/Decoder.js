import { ArrayChunk, ArrayRga } from '../../../types/rga-array/ArrayRga';
import { BinaryChunk, BinaryRga } from '../../../types/rga-binary/BinaryRga';
import { ClockTable } from '../../../../json-crdt-patch/codec/clock/ClockTable';
import { Const } from '../../../types/const/Const';
import { CrdtDecoder } from '../../../../json-crdt-patch/util/binary/CrdtDecoder';
import { Timestamp, VectorClock } from '../../../../json-crdt-patch/clock';
import { Model, UNDEFINED } from '../../../model';
import { MsgPackDecoderFast } from '../../../../json-pack/msgpack';
import { ObjectLww } from '../../../types/lww-object/ObjectLww';
import { StringChunk, StringRga } from '../../../types/rga-string/StringRga';
import { ValueLww } from '../../../types/lww-value/ValueLww';
export class Decoder {
    dec = new MsgPackDecoderFast(new CrdtDecoder());
    doc;
    clockTable;
    decode(fields, ModelConstructor = Model) {
        const reader = this.dec.reader;
        reader.reset(fields.c);
        const clockTable = (this.clockTable = ClockTable.decode(reader));
        return this.decodeFields(clockTable, fields, ModelConstructor);
    }
    decodeFields(clockTable, fields, ModelConstructor = Model) {
        const reader = this.dec.reader;
        const firstClock = clockTable.byIdx[0];
        const vectorClock = new VectorClock(firstClock.sid, firstClock.time + 1);
        const doc = (this.doc = new ModelConstructor(vectorClock));
        const root = fields.r;
        if (root && root.length) {
            reader.reset(root);
            const rootValue = this.ts();
            doc.root.set(rootValue);
        }
        const docIndex = doc.index;
        for (const field in fields) {
            if (field.length < 3)
                continue;
            const arr = fields[field];
            const id = clockTable.parseField(field);
            reader.reset(arr);
            const node = this.decodeNode(id);
            docIndex.set(node);
        }
        return doc;
    }
    ts() {
        const [sessionIndex, timeDiff] = this.dec.reader.id();
        return new Timestamp(this.clockTable.byIdx[sessionIndex].sid, timeDiff);
    }
    decodeNode(id) {
        const reader = this.dec.reader;
        const byte = reader.u8();
        if (byte <= 0b10001111)
            return this.cObj(id, byte & 0b1111);
        else if (byte <= 0b10011111)
            return this.cArr(id, byte & 0b1111);
        else if (byte <= 0b10111111)
            return this.cStr(id, byte & 0b11111);
        else {
            switch (byte) {
                case 0xc4:
                    return this.cBin(id, reader.u8());
                case 0xc5:
                    return this.cBin(id, reader.u16());
                case 0xc6:
                    return this.cBin(id, reader.u32());
                case 0xd4:
                    return this.cConst(id);
                case 0xd5:
                    return new Const(id, this.ts());
                case 0xd6:
                    return this.cVal(id);
                case 0xde:
                    return this.cObj(id, reader.u16());
                case 0xdf:
                    return this.cObj(id, reader.u32());
                case 0xdc:
                    return this.cArr(id, reader.u16());
                case 0xdd:
                    return this.cArr(id, reader.u32());
                case 0xd9:
                    return this.cStr(id, reader.u8());
                case 0xda:
                    return this.cStr(id, reader.u16());
                case 0xdb:
                    return this.cStr(id, reader.u32());
            }
        }
        return UNDEFINED;
    }
    cConst(id) {
        const val = this.dec.val();
        return new Const(id, val);
    }
    cVal(id) {
        const val = this.ts();
        return new ValueLww(this.doc, id, val);
    }
    cObj(id, length) {
        const decoder = this.dec;
        const obj = new ObjectLww(this.doc, id);
        const keys = obj.keys;
        for (let i = 0; i < length; i++) {
            const key = String(decoder.val());
            const val = this.ts();
            keys.set(key, val);
        }
        return obj;
    }
    cStr(id, length) {
        const decoder = this.dec;
        const node = new StringRga(id);
        node.ingest(length, () => {
            const chunkId = this.ts();
            const val = decoder.val();
            if (typeof val === 'number')
                return new StringChunk(chunkId, val, '');
            const data = String(val);
            return new StringChunk(chunkId, data.length, data);
        });
        return node;
    }
    cBin(id, length) {
        const decoder = this.dec;
        const reader = decoder.reader;
        const node = new BinaryRga(id);
        node.ingest(length, () => {
            const chunkId = this.ts();
            const [deleted, length] = reader.b1vu28();
            if (deleted)
                return new BinaryChunk(chunkId, length, undefined);
            const data = reader.buf(length);
            return new BinaryChunk(chunkId, length, data);
        });
        return node;
    }
    cArr(id, length) {
        const decoder = this.dec;
        const reader = decoder.reader;
        const node = new ArrayRga(this.doc, id);
        node.ingest(length, () => {
            const chunkId = this.ts();
            const [deleted, length] = reader.b1vu28();
            if (deleted)
                return new ArrayChunk(chunkId, length, undefined);
            const data = [];
            for (let i = 0; i < length; i++)
                data.push(this.ts());
            return new ArrayChunk(chunkId, length, data);
        });
        return node;
    }
}

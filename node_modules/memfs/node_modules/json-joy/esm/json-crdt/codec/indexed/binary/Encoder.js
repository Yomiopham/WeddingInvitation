import { Timestamp } from '../../../../json-crdt-patch/clock';
import { ClockTable } from '../../../../json-crdt-patch/codec/clock/ClockTable';
import { CrdtWriter } from '../../../../json-crdt-patch/util/binary/CrdtEncoder';
import { MsgPackEncoder } from '../../../../json-pack/msgpack';
import { Const } from '../../../types/const/Const';
import { ObjectLww } from '../../../types/lww-object/ObjectLww';
import { ValueLww } from '../../../types/lww-value/ValueLww';
import { ArrayRga } from '../../../types/rga-array/ArrayRga';
import { BinaryRga } from '../../../types/rga-binary/BinaryRga';
import { StringRga } from '../../../types/rga-string/StringRga';
const EMPTY = new Uint8Array(0);
export class Encoder {
    clockTable;
    enc = new MsgPackEncoder(new CrdtWriter());
    model;
    encode(doc, clockTable = ClockTable.from(doc.clock)) {
        this.clockTable = clockTable;
        const writer = this.enc.writer;
        writer.reset();
        clockTable.write(writer);
        const encodedClock = writer.flush();
        const rootValueId = doc.root.val;
        const model = (this.model = {
            c: encodedClock,
        });
        if (rootValueId.sid !== 0) {
            writer.reset();
            this.ts(rootValueId);
            model.r = writer.flush();
        }
        doc.index.entries.forEach(this.onNode);
        return model;
    }
    onNode = (map, sid) => {
        const model = this.model;
        const sidIndex = this.clockTable.getBySid(sid).index;
        const sidFieldPart = sidIndex.toString(36) + '_';
        map.forEach((node, time) => {
            const field = (sidFieldPart + time.toString(36));
            model[field] = this.encodeNode(node);
        });
    };
    encodeNode(node) {
        if (node instanceof ValueLww)
            return this.encodeVal(node);
        else if (node instanceof Const)
            return this.encodeConst(node);
        else if (node instanceof StringRga)
            return this.encodeStr(node);
        else if (node instanceof ObjectLww)
            return this.encodeObj(node);
        else if (node instanceof ArrayRga)
            return this.encodeArr(node);
        else if (node instanceof BinaryRga)
            return this.encodeBin(node);
        else
            return EMPTY;
    }
    ts(id) {
        const index = this.clockTable.getBySid(id.sid).index;
        this.enc.writer.id(index, id.time);
    }
    encodeVal(node) {
        const writer = this.enc.writer;
        const child = node.node();
        writer.reset();
        writer.u8(0xd6);
        this.ts(child.id);
        return writer.flush();
    }
    encodeConst(node) {
        const encoder = this.enc;
        const writer = encoder.writer;
        const val = node.val;
        writer.reset();
        if (val instanceof Timestamp) {
            writer.u8(0xd5);
            this.ts(val);
        }
        else {
            writer.u8(0xd4);
            encoder.writeAny(node.val);
        }
        return writer.flush();
    }
    encodeStr(node) {
        const encoder = this.enc;
        const writer = encoder.writer;
        writer.reset();
        encoder.writeStrHdr(node.size());
        for (let chunk = node.first(); chunk; chunk = node.next(chunk)) {
            this.ts(chunk.id);
            if (chunk.del)
                encoder.u32(chunk.span);
            else
                encoder.encodeString(chunk.data);
        }
        return writer.flush();
    }
    encodeBin(node) {
        const encoder = this.enc;
        const writer = encoder.writer;
        writer.reset();
        encoder.writeBinHdr(node.size());
        for (let chunk = node.first(); chunk; chunk = node.next(chunk)) {
            this.ts(chunk.id);
            const deleted = chunk.del;
            const length = chunk.span;
            writer.b1vu28(deleted, length);
            if (deleted)
                continue;
            writer.buf(chunk.data, length);
        }
        return writer.flush();
    }
    encodeObj(node) {
        const encoder = this.enc;
        const writer = encoder.writer;
        writer.reset();
        encoder.writeObjHdr(node.keys.size);
        node.keys.forEach(this.onObjectKey);
        return writer.flush();
    }
    onObjectKey = (value, key) => {
        this.enc.writeStr(key);
        this.ts(value);
    };
    encodeArr(node) {
        const encoder = this.enc;
        const writer = encoder.writer;
        writer.reset();
        encoder.writeArrHdr(node.size());
        for (let chunk = node.first(); chunk; chunk = node.next(chunk)) {
            const length = chunk.span;
            const deleted = chunk.del;
            this.ts(chunk.id);
            writer.b1vu28(deleted, length);
            if (deleted)
                continue;
            const data = chunk.data;
            for (let i = 0; i < length; i++)
                this.ts(data[i]);
        }
        return writer.flush();
    }
}

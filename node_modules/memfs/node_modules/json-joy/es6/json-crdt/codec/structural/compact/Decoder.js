"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Decoder = void 0;
const ArrayRga_1 = require("../../../types/rga-array/ArrayRga");
const BinaryRga_1 = require("../../../types/rga-binary/BinaryRga");
const ClockDecoder_1 = require("../../../../json-crdt-patch/codec/clock/ClockDecoder");
const Const_1 = require("../../../types/const/Const");
const RootLww_1 = require("../../../types/lww-root/RootLww");
const clock_1 = require("../../../../json-crdt-patch/clock");
const Model_1 = require("../../../model/Model");
const ObjectLww_1 = require("../../../types/lww-object/ObjectLww");
const constants_1 = require("../../../../json-crdt-patch/constants");
const StringRga_1 = require("../../../types/rga-string/StringRga");
const ValueLww_1 = require("../../../types/lww-value/ValueLww");
const ArrayLww_1 = require("../../../types/lww-array/ArrayLww");
class Decoder {
    decode(data) {
        const x = data[0];
        const isServerTime = typeof x === 'number';
        if (isServerTime) {
            this.time = x;
        }
        else {
            this.clockDecoder = ClockDecoder_1.ClockDecoder.fromArr(x);
        }
        const doc = isServerTime ? Model_1.Model.withServerClock(x) : Model_1.Model.withLogicalClock(this.clockDecoder.clock);
        const val = data[1] ? this.decodeNode(doc, data[1]) : Model_1.UNDEFINED;
        doc.root = new RootLww_1.RootLww(doc, val.id);
        return doc;
    }
    ts(arr, index) {
        const x = arr[index];
        if (typeof x === 'number') {
            if (x < 0) {
                const sessionIndex = -x;
                const timeDiff = arr[index + 1];
                return [this.clockDecoder.decodeId(sessionIndex, timeDiff), index + 2];
            }
            else {
                return [new clock_1.Timestamp(1, this.time - x), index + 1];
            }
        }
        else {
            const time = x[0];
            switch (time) {
                case constants_1.ORIGIN.time:
                    return [constants_1.ORIGIN, index + 1];
                default:
                    return [new clock_1.Timestamp(0, time), index + 1];
            }
        }
    }
    decodeNode(doc, data) {
        if (data instanceof Array) {
            switch (data[0]) {
                case 3:
                    return this.decodeObj(doc, data);
                case 5:
                    return this.decodeArr(doc, data);
                case 4:
                    return this.decodeStr(doc, data);
                case 2:
                    return this.decodeVal(doc, data);
                case 1:
                    return this.decodeConst(doc, data);
                case 8:
                    return this.decodeConstId(doc, data);
                case 6:
                    return this.decodeBin(doc, data);
                case 7:
                    return this.decodeTup(doc, data);
            }
        }
        throw new Error('UNKNOWN_NODE');
    }
    decodeObj(doc, data) {
        const [id, index] = this.ts(data, 1);
        const obj = new ObjectLww_1.ObjectLww(doc, id);
        const length = data.length;
        for (let i = index; i < length;) {
            const key = data[i];
            const val = this.decodeNode(doc, data[++i]);
            obj.put(key, val.id);
            i++;
        }
        doc.index.set(obj);
        return obj;
    }
    decodeTup(doc, data) {
        const [id, index] = this.ts(data, 1);
        const obj = new ArrayLww_1.ArrayLww(doc, id);
        const length = data.length;
        const elements = obj.elements;
        for (let i = index; i < length;) {
            const component = data[i++];
            if (!component)
                elements.push(undefined);
            else {
                const node = this.decodeNode(doc, component);
                elements.push(node.id);
            }
        }
        doc.index.set(obj);
        return obj;
    }
    decodeArr(doc, data) {
        const size = data[1];
        const [id, index] = this.ts(data, 2);
        const obj = new ArrayRga_1.ArrayRga(doc, id);
        const self = this;
        let i = index;
        obj.ingest(size, () => {
            const [chunkId, idx] = self.ts(data, i);
            const content = data[idx];
            i = idx + 1;
            if (typeof content === 'number')
                return new ArrayRga_1.ArrayChunk(chunkId, content, undefined);
            const ids = content.map((c) => this.decodeNode(doc, c).id);
            return new ArrayRga_1.ArrayChunk(chunkId, content.length, ids);
        });
        doc.index.set(obj);
        return obj;
    }
    decodeStr(doc, data) {
        const size = data[1];
        const [id, index] = this.ts(data, 2);
        const node = new StringRga_1.StringRga(id);
        const self = this;
        let i = index;
        node.ingest(size, () => {
            const [chunkId, idx] = self.ts(data, i);
            const content = data[idx];
            i = idx + 1;
            if (typeof content === 'number')
                return new StringRga_1.StringChunk(chunkId, content, '');
            return new StringRga_1.StringChunk(chunkId, content.length, content);
        });
        doc.index.set(node);
        return node;
    }
    decodeBin(doc, data) {
        const size = data[1];
        const [id, index] = this.ts(data, 2);
        const node = new BinaryRga_1.BinaryRga(id);
        const self = this;
        let i = index;
        node.ingest(size, () => {
            const [chunkId, idx] = self.ts(data, i);
            const content = data[idx];
            i = idx + 1;
            if (typeof content === 'number')
                return new BinaryRga_1.BinaryChunk(chunkId, content, undefined);
            const buf = content;
            return new BinaryRga_1.BinaryChunk(chunkId, buf.length, buf);
        });
        doc.index.set(node);
        return node;
    }
    decodeVal(doc, data) {
        const [id, index] = this.ts(data, 1);
        const child = this.decodeNode(doc, data[index]);
        const obj = new ValueLww_1.ValueLww(doc, id, child.id);
        doc.index.set(obj);
        return obj;
    }
    decodeConst(doc, data) {
        const [id, index] = this.ts(data, 1);
        const value = data[index];
        const obj = new Const_1.Const(id, value);
        doc.index.set(obj);
        return obj;
    }
    decodeConstId(doc, data) {
        const [id, index] = this.ts(data, 1);
        const val = this.ts(data, index)[0];
        const obj = new Const_1.Const(id, val);
        doc.index.set(obj);
        return obj;
    }
}
exports.Decoder = Decoder;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Encoder = void 0;
const ArrayRga_1 = require("../../../types/rga-array/ArrayRga");
const BinaryRga_1 = require("../../../types/rga-binary/BinaryRga");
const ClockEncoder_1 = require("../../../../json-crdt-patch/codec/clock/ClockEncoder");
const Const_1 = require("../../../types/const/Const");
const clock_1 = require("../../../../json-crdt-patch/clock");
const ObjectLww_1 = require("../../../types/lww-object/ObjectLww");
const StringRga_1 = require("../../../types/rga-string/StringRga");
const ValueLww_1 = require("../../../types/lww-value/ValueLww");
const ArrayLww_1 = require("../../../types/lww-array/ArrayLww");
class Encoder {
    encode(model) {
        this.model = model;
        const isServerTime = model.clock.sid === 1;
        const clock = model.clock;
        const arr = isServerTime ? [clock.time] : [null];
        if (isServerTime) {
            this.time = clock.time;
        }
        else {
            this.clock = new ClockEncoder_1.ClockEncoder();
            this.clock.reset(model.clock);
        }
        this.encodeRoot(arr, model.root);
        if (!isServerTime)
            arr[0] = this.clock.toJson();
        return arr;
    }
    ts(arr, ts) {
        switch (ts.sid) {
            case 0: {
                arr.push([ts.time]);
                break;
            }
            case 1: {
                arr.push(this.time - ts.time);
                break;
            }
            default: {
                const relativeId = this.clock.append(ts);
                arr.push(-relativeId.sessionIndex, relativeId.timeDiff);
            }
        }
    }
    encodeRoot(arr, root) {
        if (!root.val.time)
            arr.push(0);
        else
            this.cNode(arr, root.node());
    }
    cNode(arr, node) {
        if (node instanceof ObjectLww_1.ObjectLww)
            return this.encodeObj(arr, node);
        else if (node instanceof ArrayRga_1.ArrayRga)
            return this.encodeArr(arr, node);
        else if (node instanceof StringRga_1.StringRga)
            return this.encodeStr(arr, node);
        else if (node instanceof ValueLww_1.ValueLww)
            return this.cVal(arr, node);
        else if (node instanceof ArrayLww_1.ArrayLww)
            return this.cTup(arr, node);
        else if (node instanceof Const_1.Const)
            return this.cConst(arr, node);
        else if (node instanceof BinaryRga_1.BinaryRga)
            return this.encodeBin(arr, node);
        throw new Error('UNKNOWN_NODE');
    }
    encodeObj(arr, obj) {
        const res = [3];
        arr.push(res);
        this.ts(res, obj.id);
        obj.nodes((node, key) => {
            res.push(key);
            this.cNode(res, node);
        });
    }
    cTup(arr, obj) {
        const res = [7];
        arr.push(res);
        this.ts(res, obj.id);
        const elements = obj.elements;
        const length = elements.length;
        const index = this.model.index;
        for (let i = 0; i < length; i++) {
            const elementId = elements[i];
            if (!elementId)
                res.push(0);
            else {
                const node = index.get(elementId);
                this.cNode(res, node);
            }
        }
    }
    encodeArr(arr, obj) {
        const res = [5, obj.size()];
        arr.push(res);
        this.ts(res, obj.id);
        const iterator = obj.iterator();
        let chunk;
        while ((chunk = iterator()))
            this.encodeArrChunk(res, chunk);
    }
    encodeArrChunk(arr, chunk) {
        this.ts(arr, chunk.id);
        if (chunk.del)
            arr.push(chunk.span);
        else {
            const nodes = [];
            const index = this.model.index;
            for (const n of chunk.data)
                this.cNode(nodes, index.get(n));
            arr.push(nodes);
        }
    }
    encodeStr(arr, obj) {
        const res = [4, obj.size()];
        arr.push(res);
        this.ts(res, obj.id);
        const iterator = obj.iterator();
        let chunk;
        while ((chunk = iterator()))
            this.encodeStrChunk(res, chunk);
    }
    encodeStrChunk(arr, chunk) {
        this.ts(arr, chunk.id);
        arr.push(chunk.del ? chunk.span : chunk.data);
    }
    encodeBin(arr, obj) {
        const res = [6, obj.size()];
        arr.push(res);
        this.ts(res, obj.id);
        const iterator = obj.iterator();
        let chunk;
        while ((chunk = iterator()))
            this.encodeBinChunk(res, chunk);
    }
    encodeBinChunk(arr, chunk) {
        this.ts(arr, chunk.id);
        arr.push(chunk.del ? chunk.span : chunk.data);
    }
    cVal(arr, obj) {
        const res = [2];
        arr.push(res);
        this.ts(res, obj.id);
        this.cNode(res, obj.node());
    }
    cConst(arr, obj) {
        const val = obj.val;
        const res = [];
        if (val instanceof clock_1.Timestamp) {
            res.push(8);
            this.ts(res, obj.id);
            this.ts(res, val);
        }
        else {
            res.push(1);
            this.ts(res, obj.id);
            if (val !== undefined)
                res.push(val);
        }
        arr.push(res);
    }
}
exports.Encoder = Encoder;
